---
phase: 01-foundation-configuration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - go.mod
  - go.sum
  - internal/models/scan.go
  - internal/models/host.go
  - internal/models/types.go
  - internal/config/config.go
  - internal/config/defaults.go
  - configs/reconpipe.yaml
autonomous: true

must_haves:
  truths:
    - "Go module initializes and builds without errors"
    - "Data models represent scan, host, port, subdomain, and vulnerability entities"
    - "YAML config file is parsed into typed Go structs with validation"
    - "Default config is generated with sensible tool parameters and rate limits"
  artifacts:
    - path: "go.mod"
      provides: "Go module definition"
      contains: "module github.com/hakim/reconpipe"
    - path: "internal/models/scan.go"
      provides: "Scan and ScanMeta data models"
      exports: ["Scan", "ScanMeta", "ScanStatus"]
    - path: "internal/models/host.go"
      provides: "Host, Port, Subdomain models"
      exports: ["Host", "Port", "Subdomain", "DNSRecord"]
    - path: "internal/config/config.go"
      provides: "Config loading and validation"
      exports: ["Config", "Load", "LoadDefault"]
    - path: "configs/reconpipe.yaml"
      provides: "Default YAML config template"
      contains: "rate_limits"
  key_links:
    - from: "internal/config/config.go"
      to: "configs/reconpipe.yaml"
      via: "viper YAML unmarshalling"
      pattern: "viper\\.Unmarshal"
    - from: "internal/models/scan.go"
      to: "internal/models/host.go"
      via: "Scan contains []Host"
      pattern: "Hosts.*\\[\\]Host"
---

<objective>
Initialize Go project, define core data models, and implement YAML configuration loading.

Purpose: Every subsequent phase depends on these data types and config structures. This is the bedrock.
Output: Buildable Go module with typed models and working config parser.
</objective>

<execution_context>
@C:/Users/Hakim/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Hakim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Go module and define data models</name>
  <files>go.mod, internal/models/scan.go, internal/models/host.go, internal/models/types.go</files>
  <action>
    1. Run `go mod init github.com/hakim/reconpipe` in project root.

    2. Create `internal/models/types.go`:
       - Package `models`
       - `type ScanStatus string` with constants: StatusPending, StatusRunning, StatusComplete, StatusFailed
       - `type Severity string` with constants: SeverityCritical, SeverityHigh, SeverityMedium, SeverityLow, SeverityInfo
       - `type DNSRecordType string` with constants for A, AAAA, CNAME, MX, TXT

    3. Create `internal/models/scan.go`:
       - `type ScanMeta struct` with fields: ID (string, UUID), Target (string, root domain), StartedAt (time.Time), CompletedAt (*time.Time), Status (ScanStatus), ScanDir (string, filesystem path), ToolVersions (map[string]string), StagesRun ([]string)
       - `type Scan struct` embedding ScanMeta plus: Subdomains ([]Subdomain), Hosts ([]Host), Vulnerabilities ([]Vulnerability)
       - Constructor `NewScan(target string) *Scan` that generates UUID, sets StartedAt to now, Status to Pending

    4. Create `internal/models/host.go`:
       - `type Subdomain struct`: Name (string), Domain (string), Source (string, e.g. "subfinder"/"tlsx"), Resolved (bool), IPs ([]string), DNSRecords ([]DNSRecord), IsCDN (bool), CDNProvider (string), IsDangling (bool)
       - `type DNSRecord struct`: Type (DNSRecordType), Value (string)
       - `type Host struct`: IP (string), Subdomains ([]string), Ports ([]Port), IsCDN (bool), CDNProvider (string)
       - `type Port struct`: Number (int), Protocol (string), Service (string), Version (string), State (string)
       - `type Vulnerability struct`: TemplateID (string), Name (string), Severity (Severity), Host (string), Port (int), URL (string), Description (string), MatchedAt (string)
       - `type HTTPProbe struct`: URL (string), StatusCode (int), Title (string), ContentLength (int64), Technologies ([]string), Host (string), IP (string), Port (int), ScreenshotPath (string)

    5. Run `go build ./...` to verify compilation.
  </action>
  <verify>Run `go build ./...` from project root -- must succeed with zero errors.</verify>
  <done>Go module exists, all model types compile, models cover scan/host/port/subdomain/vulnerability/httpprobe entities.</done>
</task>

<task type="auto">
  <name>Task 2: Implement YAML config loading with defaults</name>
  <files>internal/config/config.go, internal/config/defaults.go, configs/reconpipe.yaml, go.mod, go.sum</files>
  <action>
    1. Run `go get github.com/spf13/viper` to add viper dependency.

    2. Create `internal/config/config.go`:
       - Package `config`
       - `type Config struct` with nested structs:
         ```
         Config {
           ScanDir     string          `mapstructure:"scan_dir"`     // default "scans"
           DBPath      string          `mapstructure:"db_path"`      // default "reconpipe.db"
           Tools       ToolsConfig     `mapstructure:"tools"`
           RateLimits  RateLimitConfig `mapstructure:"rate_limits"`
           Stages      StagesConfig    `mapstructure:"stages"`
         }
         ```
       - `type ToolsConfig struct` with fields for each external tool (Subfinder, Tlsx, Dig, Masscan, Nmap, Httpx, Gowitness, Cdncheck, Nuclei) -- each a `ToolConfig struct` with Path (string), Args ([]string), Timeout (duration string like "5m")
       - `type RateLimitConfig struct` with: SubfinderThreads (int, default 10), MasscanRate (int, default 1000), NmapMaxParallel (int, default 5), HttpxThreads (int, default 25), NucleiThreads (int, default 10), NucleiRateLimit (int, default 150)
       - `type StagesConfig struct` with: Enable ([]string), Skip ([]string) -- for future pipeline control
       - `func Load(path string) (*Config, error)` -- uses viper to read YAML file, unmarshal into Config struct. If path is empty, search current dir and ~/.config/reconpipe/ for reconpipe.yaml.
       - `func (c *Config) Validate() error` -- checks ScanDir is not empty, rate limits are positive, returns aggregated errors.

    3. Create `internal/config/defaults.go`:
       - `func DefaultConfig() *Config` -- returns Config with all defaults populated (scan_dir="scans", db_path="reconpipe.db", sensible rate limits as listed above, tool timeouts of 5m each)
       - `func WriteDefault(path string) error` -- marshals DefaultConfig to YAML and writes to path. Use `gopkg.in/yaml.v3` for clean output (viper's write can be messy).

    4. Run `go get gopkg.in/yaml.v3` for clean YAML writing.

    5. Create `configs/reconpipe.yaml` -- a static example/default config file with all fields documented via YAML comments explaining each option. This serves as user reference.

    6. Run `go build ./...` to verify compilation.
  </action>
  <verify>Run `go build ./...` -- must succeed. Run `go vet ./...` -- no warnings.</verify>
  <done>Config struct loads from YAML via viper, defaults are sensible, validation catches bad values, example config file exists with inline documentation.</done>
</task>

</tasks>

<verification>
- `go build ./...` succeeds
- `go vet ./...` reports no issues
- `configs/reconpipe.yaml` is valid YAML (parseable)
- All model structs have exported fields with appropriate types
- Config struct covers tool params, rate limits, scan directory, and DB path
</verification>

<success_criteria>
Go module compiles cleanly. Data models represent all pipeline entities (scan, subdomain, host, port, vulnerability, HTTP probe). YAML config loads with viper and validates. Default config template exists.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-configuration/01-01-SUMMARY.md`
</output>
