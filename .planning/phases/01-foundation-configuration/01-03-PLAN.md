---
phase: 01-foundation-configuration
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - cmd/reconpipe/main.go
  - cmd/reconpipe/root.go
  - cmd/reconpipe/check.go
  - cmd/reconpipe/init_cmd.go
  - internal/tools/checker.go
  - go.mod
  - go.sum
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "User can run `reconpipe check` and see which external tools are installed vs missing"
    - "Missing tools show install instructions (go install or package manager)"
    - "User can run `reconpipe init` to generate a default config file"
    - "CLI binary builds and runs with --help showing available commands"
  artifacts:
    - path: "cmd/reconpipe/main.go"
      provides: "CLI entry point"
      contains: "func main()"
    - path: "cmd/reconpipe/root.go"
      provides: "Root cobra command with global flags"
      exports: ["Execute"]
    - path: "cmd/reconpipe/check.go"
      provides: "check subcommand implementation"
      contains: "reconpipe check"
    - path: "cmd/reconpipe/init_cmd.go"
      provides: "init subcommand that writes default config"
      contains: "reconpipe init"
    - path: "internal/tools/checker.go"
      provides: "External tool detection and version checking"
      exports: ["CheckTools", "ToolRequirement", "CheckResult"]
  key_links:
    - from: "cmd/reconpipe/check.go"
      to: "internal/tools/checker.go"
      via: "calls CheckTools and renders results"
      pattern: "tools\\.CheckTools"
    - from: "cmd/reconpipe/init_cmd.go"
      to: "internal/config/defaults.go"
      via: "calls WriteDefault to generate config"
      pattern: "config\\.WriteDefault"
    - from: "cmd/reconpipe/root.go"
      to: "internal/config/config.go"
      via: "loads config on startup via persistent pre-run"
      pattern: "config\\.Load"
---

<objective>
Build the CLI skeleton with cobra, implement the `check` command for external tool detection and the `init` command for config generation.

Purpose: Users need a working binary they can run. `check` validates their environment before scanning. `init` bootstraps their config. This completes Phase 1's user-facing deliverables.
Output: Buildable `reconpipe` binary with `check` and `init` subcommands.
</objective>

<execution_context>
@C:/Users/Hakim/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Hakim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-configuration/01-01-SUMMARY.md
@.planning/phases/01-foundation-configuration/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tool checker and CLI skeleton with check command</name>
  <files>internal/tools/checker.go, cmd/reconpipe/main.go, cmd/reconpipe/root.go, cmd/reconpipe/check.go, go.mod, go.sum, .gitignore</files>
  <action>
    1. Run `go get github.com/spf13/cobra@latest` to add cobra dependency.

    2. Create `internal/tools/checker.go`:
       - Package `tools`
       - `type ToolRequirement struct`: Name (string), Binary (string, the executable name), Required (bool), InstallCmd (string, e.g. "go install -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest"), Purpose (string, one-line description)
       - `type CheckResult struct`: Tool (ToolRequirement), Found (bool), Path (string, resolved path), Version (string)
       - `func DefaultTools() []ToolRequirement` -- returns the 9 external tools:
         * subfinder (go install github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest) - "Subdomain discovery"
         * tlsx (go install github.com/projectdiscovery/tlsx/cmd/tlsx@latest) - "TLS subdomain discovery"
         * dig (system package: dnsutils/bind-tools) - "DNS resolution"
         * cdncheck (go install github.com/projectdiscovery/cdncheck/cmd/cdncheck@latest) - "CDN detection"
         * masscan (system package or github.com/robertdavidgraham/masscan) - "Fast port scanning"
         * nmap (system package) - "Service fingerprinting"
         * httpx (go install github.com/projectdiscovery/httpx/cmd/httpx@latest) - "HTTP probing"
         * gowitness (go install github.com/sensepost/gowitness@latest) - "Screenshot capture"
         * nuclei (go install github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest) - "Vulnerability scanning"
       - `func CheckTools(tools []ToolRequirement) []CheckResult` -- for each tool, use exec.LookPath to find binary. If found, try running `{binary} -version` or `{binary} --version` to capture version string (best effort -- some tools use different flags, catch errors gracefully). Return CheckResult for each.
       - `func CheckTool(tool ToolRequirement) CheckResult` -- single tool check.

    3. Create `cmd/reconpipe/main.go`:
       - Package `main`
       - `func main()` calls `Execute()` from root.go

    4. Create `cmd/reconpipe/root.go`:
       - Define rootCmd cobra.Command: Use "reconpipe", Short "Subdomain-to-vulnerability recon pipeline", Long description.
       - Global persistent flags: --config (string, path to config file, default "reconpipe.yaml"), --verbose (bool)
       - `func Execute()` calls rootCmd.Execute(), os.Exit(1) on error.
       - PersistentPreRunE: load config using config.Load(cfgFile). Store loaded config in a package-level var for subcommands to access. If config file not found, that's OK for `check` and `init` commands (they work without config). Use cobra.OnInitialize pattern.

    5. Create `cmd/reconpipe/check.go`:
       - Define checkCmd cobra.Command: Use "check", Short "Check for required external tools"
       - Run function: call tools.CheckTools(tools.DefaultTools()), format output as table:
         ```
         Tool        Status    Version           Install
         ----        ------    -------           -------
         subfinder   OK        v2.6.3            -
         masscan     MISSING   -                 apt install masscan
         nmap        OK        7.94              -
         ```
       - Use color/emoji-free output (this is a pentest tool, keep it clean). Use checkmark/X symbols: [+] found, [-] missing.
       - Print summary: "X/9 tools found. Y required tools missing." Exit with code 1 if any required tools are missing.
       - Add checkCmd to rootCmd in init().

    6. Create `.gitignore` with standard Go entries: binary output (reconpipe, reconpipe.exe), vendor/, *.db, scans/, .env, *.log.

    7. Run `go build -o reconpipe ./cmd/reconpipe/` to verify binary builds.
  </action>
  <verify>Run `go build -o reconpipe ./cmd/reconpipe/` -- must produce binary. Run `./reconpipe --help` -- must show usage with check subcommand. Run `./reconpipe check` -- must list tools with found/missing status.</verify>
  <done>Binary builds. `reconpipe --help` shows available commands. `reconpipe check` reports tool availability with install instructions for missing tools. Exit code 1 if required tools missing, 0 if all present.</done>
</task>

<task type="auto">
  <name>Task 2: Add init command and wire config + storage integration</name>
  <files>cmd/reconpipe/init_cmd.go, cmd/reconpipe/root.go</files>
  <action>
    1. Create `cmd/reconpipe/init_cmd.go`:
       - Define initCmd cobra.Command: Use "init", Short "Initialize reconpipe with default configuration"
       - Run function:
         * Check if reconpipe.yaml already exists -- if so, print warning "Config file already exists at {path}. Use --force to overwrite." and exit (unless --force flag is set).
         * Call config.WriteDefault("reconpipe.yaml") to generate default config.
         * Print "Created reconpipe.yaml with default configuration."
         * Also create the default scan directory (scans/) using storage.EnsureDir.
         * Also initialize the bbolt database using storage.NewStore at the configured db_path, then immediately close it. Print "Initialized database at reconpipe.db"
         * Print summary: "ReconPipe initialized. Run 'reconpipe check' to verify your tools."
       - Flags: --force (bool, overwrite existing config), --dir (string, output directory, default ".")
       - Add initCmd to rootCmd in init().

    2. Update `cmd/reconpipe/root.go` if needed:
       - Ensure config loading in PersistentPreRunE gracefully handles missing config (don't error on `check` or `init` subcommands -- they should work without existing config).
       - Add version flag: --version prints "reconpipe v0.1.0-dev"

    3. Run `go build -o reconpipe ./cmd/reconpipe/` and test:
       - `./reconpipe init` should create reconpipe.yaml and reconpipe.db
       - `./reconpipe check` should still work
       - `./reconpipe --version` should print version

    4. Clean up generated test files (reconpipe.yaml, reconpipe.db, scans/) after verification.
  </action>
  <verify>Run `go build -o reconpipe ./cmd/reconpipe/` -- binary builds. Run `./reconpipe init` -- creates config + db. Run `./reconpipe check` -- lists tools. Verify reconpipe.yaml is valid YAML with comments.</verify>
  <done>`reconpipe init` generates default config file with documentation comments, creates scan directory, initializes bbolt database. `reconpipe check` works independently. `reconpipe --version` prints version. All Phase 1 success criteria met.</done>
</task>

</tasks>

<verification>
- `go build -o reconpipe ./cmd/reconpipe/` produces working binary
- `./reconpipe --help` shows root help with check and init subcommands
- `./reconpipe check` outputs tool status table with install instructions for missing tools
- `./reconpipe init` creates reconpipe.yaml, scans/ directory, and reconpipe.db
- `./reconpipe init` on existing config warns without --force
- `go vet ./...` reports no issues
- All Phase 1 success criteria verified:
  1. YAML config with tool params and rate limits (reconpipe.yaml)
  2. CLI shows missing tools with install instructions (reconpipe check)
  3. Structured scan directories created (scans/domain_timestamp/)
  4. Scan metadata persists to bbolt (reconpipe.db via storage package)
</verification>

<success_criteria>
Working `reconpipe` binary with `check` (tool detection with install hints) and `init` (config + storage bootstrap) commands. All Phase 1 success criteria from ROADMAP are satisfied end-to-end.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-configuration/01-03-SUMMARY.md`
</output>
