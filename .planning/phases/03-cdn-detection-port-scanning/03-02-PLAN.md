---
phase: 03-cdn-detection-port-scanning
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - internal/portscan/cdn.go
  - internal/portscan/pipeline.go
  - internal/report/ports.go
  - cmd/reconpipe/portscan.go
autonomous: true

must_haves:
  truths:
    - "CDN-hosted IPs are identified and excluded from port scanning"
    - "Non-CDN IPs are scanned by masscan for open ports"
    - "Discovered open ports are fingerprinted by nmap for service/version"
    - "Port scan results associate IPs with their corresponding subdomains"
    - "Pipeline produces ports.md report showing open ports per host"
    - "User can run 'reconpipe portscan -d domain' to execute the full pipeline"
  artifacts:
    - path: "internal/portscan/cdn.go"
      provides: "CDN filtering logic"
      exports: ["FilterCDN", "CDNFilterResult"]
    - path: "internal/portscan/pipeline.go"
      provides: "Port scanning pipeline orchestrator"
      exports: ["RunPortScan", "PortScanResult", "PortScanConfig"]
    - path: "internal/report/ports.go"
      provides: "Port scan markdown report generator"
      exports: ["WritePortReport"]
    - path: "cmd/reconpipe/portscan.go"
      provides: "CLI portscan command"
      contains: "portscanCmd"
  key_links:
    - from: "internal/portscan/cdn.go"
      to: "internal/tools/cdncheck.go"
      via: "RunCdncheck call"
      pattern: "tools\\.RunCdncheck"
    - from: "internal/portscan/pipeline.go"
      to: "internal/tools/masscan.go"
      via: "RunMasscan call"
      pattern: "tools\\.RunMasscan"
    - from: "internal/portscan/pipeline.go"
      to: "internal/tools/nmap.go"
      via: "RunNmap call"
      pattern: "tools\\.RunNmap"
    - from: "internal/portscan/pipeline.go"
      to: "internal/portscan/cdn.go"
      via: "FilterCDN call"
      pattern: "FilterCDN"
    - from: "cmd/reconpipe/portscan.go"
      to: "internal/portscan/pipeline.go"
      via: "RunPortScan call"
      pattern: "portscan\\.RunPortScan"
    - from: "cmd/reconpipe/portscan.go"
      to: "internal/report/ports.go"
      via: "WritePortReport call"
      pattern: "report\\.WritePortReport"
---

<objective>
Build the CDN filtering pipeline, port scanning orchestrator, markdown report, and CLI command for the portscan stage.

Purpose: This plan wires together the tool wrappers from Plan 01 into a working pipeline that takes Phase 2 subdomain results, filters CDN IPs, discovers ports via masscan, fingerprints services via nmap, and produces a structured ports.md report.

Output: Working `reconpipe portscan -d domain --scan-dir path` command that reads subdomains.json from a prior discover scan and produces ports.md + ports.json.
</objective>

<execution_context>
@C:/Users/Hakim/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Hakim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:/Users/Hakim/Desktop/recon-pipeline/.planning/PROJECT.md
@C:/Users/Hakim/Desktop/recon-pipeline/.planning/ROADMAP.md
@C:/Users/Hakim/Desktop/recon-pipeline/.planning/phases/03-cdn-detection-port-scanning/03-RESEARCH.md
@C:/Users/Hakim/Desktop/recon-pipeline/.planning/phases/03-cdn-detection-port-scanning/03-01-SUMMARY.md

@C:/Users/Hakim/Desktop/recon-pipeline/internal/discovery/pipeline.go
@C:/Users/Hakim/Desktop/recon-pipeline/internal/report/markdown.go
@C:/Users/Hakim/Desktop/recon-pipeline/cmd/reconpipe/discover.go
@C:/Users/Hakim/Desktop/recon-pipeline/internal/models/host.go
@C:/Users/Hakim/Desktop/recon-pipeline/internal/models/scan.go
@C:/Users/Hakim/Desktop/recon-pipeline/internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: CDN filtering and port scanning pipeline</name>
  <files>internal/portscan/cdn.go, internal/portscan/pipeline.go</files>
  <action>
Create new package `internal/portscan/`.

**internal/portscan/cdn.go:**
- Define `CDNFilterResult` struct: `CDNHosts []models.Host` (IPs classified as CDN), `ScannableIPs []string` (non-CDN IPs to port scan), `IPToSubdomains map[string][]string` (reverse mapping of IP to subdomain names).
- Create `FilterCDN(ctx context.Context, subdomains []models.Subdomain, cdncheckPath string) (*CDNFilterResult, error)`.
  - Step 1: Build IP-to-subdomain reverse map from resolved subdomains. Iterate subdomains where `Resolved == true`, for each IP in `sub.IPs`, add the subdomain name to `ipToSubs[ip]`. Also collect unique IPs into a slice.
  - Step 2: If no unique IPs, return empty result immediately.
  - Step 3: Call `tools.RunCdncheck(ctx, uniqueIPs, cdncheckPath)`.
  - Step 4: Separate results: CDN IPs become `models.Host{IP: ip, IsCDN: true, CDNProvider: cdnName, Subdomains: ipToSubs[ip]}` in CDNHosts. Non-CDN IPs go into ScannableIPs.
  - Step 5: Return CDNFilterResult with IPToSubdomains map preserved for later use.
- Print progress: `fmt.Printf("[*] CDN check: %d CDN, %d scannable\n", len(cdnHosts), len(scannableIPs))`.

**internal/portscan/pipeline.go:**
- Define `PortScanConfig` struct: `CdncheckPath string`, `MasscanPath string`, `NmapPath string`, `MasscanRate int`, `NmapMaxParallel int`, `SkipCDNCheck bool` (for when cdncheck is not installed).
- Define `PortScanResult` struct: `Target string`, `Hosts []models.Host` (all hosts including CDN-only), `CDNCount int`, `ScannedCount int`, `TotalPorts int`.
- Create `RunPortScan(ctx context.Context, subdomains []models.Subdomain, cfg PortScanConfig) (*PortScanResult, error)`.
  - Step 1: CDN filtering — call `FilterCDN(ctx, subdomains, cfg.CdncheckPath)`. If `cfg.SkipCDNCheck` is true, skip cdncheck and treat all IPs as scannable (build the IP-to-subdomain map manually, same logic as FilterCDN step 1).
  - Step 2: If no scannable IPs, print "[*] All IPs are CDN-hosted, skipping port scan", return result with only CDN hosts.
  - Step 3: Run masscan — call `tools.RunMasscan(ctx, scannableIPs, cfg.MasscanRate, cfg.MasscanPath)`. Print progress before and after.
  - Step 4: If no open ports found, print message and return result with CDN hosts + empty-port hosts.
  - Step 5: Build IP-to-ports map from masscan results: `ipPorts map[string][]int`.
  - Step 6: Run nmap — for each IP with open ports, call `tools.RunNmap(ctx, ip, ports, cfg.NmapPath)`. Print progress per IP. Respect NmapMaxParallel (for now, run sequentially — concurrent nmap deferred to Phase 6+ per project convention of sequential-first).
  - Step 7: Build Host objects — for each scanned IP, create `models.Host{IP: ip, Subdomains: ipToSubs[ip], Ports: nmapPorts, IsCDN: false}`. Convert NmapResult to models.Port (Number=NmapResult.Port, Protocol=NmapResult.Protocol, Service=NmapResult.Service, Version=NmapResult.Version, State=NmapResult.State).
  - Step 8: Combine CDN hosts + scanned hosts into result. Calculate TotalPorts by summing all port counts.
  - Step 9: Derive Target from first subdomain's Domain field.
  - Return PortScanResult.
  </action>
  <verify>
Run `cd C:/Users/Hakim/Desktop/recon-pipeline && go build ./internal/portscan/` — should compile with no errors.
  </verify>
  <done>CDN filtering separates CDN from scannable IPs. Pipeline orchestrates cdncheck -> masscan -> nmap flow. Handles edge cases: no IPs, all CDN, no open ports. Host objects associate IPs with subdomains via reverse map.</done>
</task>

<task type="auto">
  <name>Task 2: Port scan markdown report</name>
  <files>internal/report/ports.go</files>
  <action>
Create `internal/report/ports.go` following the exact pattern of `markdown.go`:
- Import the portscan package for PortScanResult type.
- Create `WritePortReport(result *portscan.PortScanResult, outputPath string) error`.
- Use `strings.Builder` (same as WriteSubdomainReport pattern).
- Report structure:
  1. **Header**: "# Port Scan Report", target, date, summary stats (total hosts, CDN filtered, scanned, total open ports).
  2. **CDN Filtered Hosts** section: table with | IP | CDN Provider | Subdomains | for hosts where IsCDN=true. Show "None found." if empty.
  3. **Open Ports by Host** section: for each non-CDN host with ports, create a subsection `### {IP} ({subdomains joined by ", "})` with a table: | Port | Protocol | State | Service | Version |. If a host has no ports, show "No open ports discovered."
  4. **Summary** section: total IPs checked, CDN filtered count, hosts with open ports, total unique ports found.
- Write to file using `os.WriteFile(outputPath, []byte(b.String()), 0644)`.
- Handle empty result gracefully (report still generates with "None found." sections).
  </action>
  <verify>
Run `cd C:/Users/Hakim/Desktop/recon-pipeline && go build ./internal/report/` — should compile with no errors.
  </verify>
  <done>WritePortReport generates a structured markdown report with CDN-filtered hosts, open ports per host with service details, and summary statistics. Follows the exact pattern of WriteSubdomainReport.</done>
</task>

<task type="auto">
  <name>Task 3: CLI portscan command</name>
  <files>cmd/reconpipe/portscan.go</files>
  <action>
Create `cmd/reconpipe/portscan.go` following the exact pattern of `discover.go`:

- Define `portscanCmd` as a `*cobra.Command` with Use: "portscan", Short: "Run CDN detection and port scanning".
- Long description explains: reads subdomain discovery results from a prior scan, filters CDN IPs via cdncheck, discovers open ports via masscan, fingerprints services via nmap.
- Flags:
  - `--domain` / `-d` (string, required) — target domain
  - `--scan-dir` (string) — path to existing scan directory from discover phase (e.g., scans/example.com_20260217_120000). If empty, find the latest scan dir for the domain (look in cfg.ScanDir for dirs matching `domain_*`, sort by name descending, pick first).
  - `--skip-cdncheck` (bool, default false) — skip CDN detection
  - `--timeout` (duration, default 30m) — overall timeout
- RunE implementation (follow discover.go steps 1-16 pattern):
  1. Pre-flight: check required tools (masscan required, nmap required, cdncheck optional — handle like tlsx in discover.go).
  2. Config check.
  3. Read subdomains.json from `{scanDir}/raw/subdomains.json`. Unmarshal JSON. The JSON file contains a DiscoveryResult object — extract Subdomains field. Filter to only resolved subdomains (Resolved==true AND len(IPs)>0).
  4. If no resolved subdomains found, print warning and exit cleanly (not an error).
  5. Create context with timeout.
  6. Build PortScanConfig from cfg values (MasscanRate from cfg.RateLimits.MasscanRate, NmapMaxParallel from cfg.RateLimits.NmapMaxParallel, tool paths empty to use PATH).
  7. Call `portscan.RunPortScan(ctx, subdomains, portScanCfg)`.
  8. Write markdown report to `{scanDir}/reports/ports.md`.
  9. Save raw JSON to `{scanDir}/raw/ports.json` (marshal PortScanResult with MarshalIndent).
  10. Open database, update scan: append "portscan" to StagesRun, set scan.Hosts from result.Hosts.
  11. Print final summary: CDN filtered count, hosts scanned, total ports found, report path.
- In `init()`: add flags, mark domain required, add to rootCmd.
- For finding latest scan dir: implement a helper `findLatestScanDir(baseDir, domain string) (string, error)` that uses `os.ReadDir`, filters entries starting with `domain_`, sorts, returns the last one's full path. If none found, return error suggesting user run discover first.
  </action>
  <verify>
Run `cd C:/Users/Hakim/Desktop/recon-pipeline && go build ./cmd/reconpipe/` — should compile with no errors. Then run `./reconpipe portscan --help` to verify the command is registered with correct flags.
  </verify>
  <done>portscan CLI command registered with cobra, reads prior discover results, orchestrates CDN filter + port scan pipeline, writes ports.md report + ports.json raw output, updates scan metadata. Handles missing cdncheck gracefully (skip CDN check with warning). Supports auto-detection of latest scan directory.</done>
</task>

</tasks>

<verification>
- `go build ./...` compiles the entire project without errors
- `go vet ./...` reports no issues
- `./reconpipe portscan --help` shows correct usage with all flags
- All new files exist: cdn.go, pipeline.go, ports.go, portscan.go
- Pipeline flow: subdomains.json -> CDN filter -> masscan -> nmap -> ports.md + ports.json
</verification>

<success_criteria>
Complete portscan pipeline working end-to-end: user runs `reconpipe portscan -d example.com` after a prior `reconpipe discover` run, and gets a ports.md report with CDN-filtered hosts, open ports, and service fingerprints. Edge cases handled: no resolved subdomains, all CDN, no open ports, missing cdncheck tool.
</success_criteria>

<output>
After completion, create `.planning/phases/03-cdn-detection-port-scanning/03-02-SUMMARY.md`
</output>
