---
phase: 03-cdn-detection-port-scanning
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/tools/cdncheck.go
  - internal/tools/masscan.go
  - internal/tools/nmap.go
autonomous: true

must_haves:
  truths:
    - "cdncheck wrapper accepts IPs via stdin and returns CDN classification per IP"
    - "masscan wrapper scans target IPs and returns discovered open ports"
    - "nmap wrapper fingerprints specific IP:port pairs and returns service/version info"
  artifacts:
    - path: "internal/tools/cdncheck.go"
      provides: "RunCdncheck function"
      exports: ["RunCdncheck", "CdncheckResult"]
    - path: "internal/tools/masscan.go"
      provides: "RunMasscan function"
      exports: ["RunMasscan", "MasscanResult"]
    - path: "internal/tools/nmap.go"
      provides: "RunNmap function"
      exports: ["RunNmap", "NmapResult"]
  key_links:
    - from: "internal/tools/cdncheck.go"
      to: "internal/tools/runner.go"
      via: "RunTool function call"
      pattern: "RunTool\\(ctx"
    - from: "internal/tools/masscan.go"
      to: "internal/tools/runner.go"
      via: "RunTool function call"
      pattern: "RunTool\\(ctx"
    - from: "internal/tools/nmap.go"
      to: "internal/tools/runner.go"
      via: "RunTool function call"
      pattern: "RunTool\\(ctx"
---

<objective>
Create tool wrappers for cdncheck, masscan, and nmap following the established pattern in internal/tools/.

Purpose: These wrappers provide the foundation for the port scanning pipeline. Each wraps a CLI tool, calls it via RunTool(), and parses its output into typed Go structs.

Output: Three new files in internal/tools/ that export Run functions matching existing conventions (subfinder.go, dig.go patterns).
</objective>

<execution_context>
@C:/Users/Hakim/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Hakim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:/Users/Hakim/Desktop/recon-pipeline/.planning/PROJECT.md
@C:/Users/Hakim/Desktop/recon-pipeline/.planning/ROADMAP.md
@C:/Users/Hakim/Desktop/recon-pipeline/.planning/phases/03-cdn-detection-port-scanning/03-RESEARCH.md

@C:/Users/Hakim/Desktop/recon-pipeline/internal/tools/runner.go
@C:/Users/Hakim/Desktop/recon-pipeline/internal/tools/subfinder.go
@C:/Users/Hakim/Desktop/recon-pipeline/internal/tools/dig.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: cdncheck and masscan tool wrappers</name>
  <files>internal/tools/cdncheck.go, internal/tools/masscan.go</files>
  <action>
Create `internal/tools/cdncheck.go`:
- Define `CdncheckResult` struct: `IP string`, `IsCDN bool`, `CDNName string`, `IsCloud bool`, `IsWAF bool`, `WAFName string` (JSON tags matching cdncheck output fields: ip, cdn, cdn_name, cloud, waf, waf_name).
- Create `RunCdncheck(ctx context.Context, ips []string, binaryPath string) ([]CdncheckResult, error)`.
- Use `binary := "cdncheck"` with binaryPath override (same pattern as subfinder.go).
- Build args: `-j` (JSON output), `-silent`.
- cdncheck reads IPs from stdin, NOT command-line args. So instead of using RunTool directly, use `exec.CommandContext` manually to pipe ips (one per line, joined with "\n") into stdin. Set WaitDelay to 5*time.Second. Read stdout/stderr concurrently (same pattern as runner.go but with stdin pipe).
- Parse JSONL stdout: one JSON object per line. Use `bufio.Scanner` + `json.Unmarshal` into CdncheckResult (same pattern as subfinder.go parsing).
- Skip empty lines, log warnings for unparseable lines (fmt.Printf warning).
- Return slice of results. If no IPs provided, return empty slice immediately.

Create `internal/tools/masscan.go`:
- Define `MasscanPort` struct: `Port int`, `Proto string`, `Status string` (JSON tags: port, proto, status).
- Define `MasscanResult` struct: `IP string`, `Ports []MasscanPort` (JSON tags: ip, ports).
- Create `RunMasscan(ctx context.Context, ips []string, rate int, binaryPath string) ([]MasscanResult, error)`.
- Use `binary := "masscan"` with binaryPath override.
- Write IPs to a temp file (os.CreateTemp), pass via `-iL` flag. Defer removal of temp file.
- Build args: `-iL tempfile`, `-p1-65535`, `--rate=N` (from rate param, default 1000 if <= 0), `-oJ tempOutputFile` (use second temp file for JSON output), `--wait 2`.
- Execute via RunTool. After execution, read the JSON output temp file.
- masscan JSON output is an array with a trailing comma issue — lines like `{ "ip": "...", ... },` — strip trailing commas before parsing. Read the temp file, clean the content (remove trailing `,\n]` pattern — replace `,\n]` with `\n]`), then json.Unmarshal into `[]MasscanResult`.
- Handle empty results (file not created or empty = no open ports found).
- Defer removal of both temp files.
- Return slice of results. If no IPs provided, return empty slice immediately.
  </action>
  <verify>
Run `cd C:/Users/Hakim/Desktop/recon-pipeline && go build ./internal/tools/` — should compile with no errors.
  </verify>
  <done>CdncheckResult and MasscanResult types defined. RunCdncheck pipes IPs to stdin and parses JSONL. RunMasscan uses temp files for input/output and handles masscan JSON quirks. Both follow existing tool wrapper conventions.</done>
</task>

<task type="auto">
  <name>Task 2: nmap tool wrapper with XML parsing</name>
  <files>internal/tools/nmap.go</files>
  <action>
Create `internal/tools/nmap.go`:
- Define XML parsing structs for nmap -oX output:
  - `nmapRun` struct with XMLName `xml:"nmaprun"`, Hosts `[]nmapHost` (xml:"host").
  - `nmapHost` struct with Addresses `[]nmapAddress` (xml:"address"), Ports `nmapPorts` (xml:"ports").
  - `nmapAddress` struct with Addr `string` (xml attr "addr"), AddrType `string` (xml attr "addrtype").
  - `nmapPorts` struct with Ports `[]nmapPort` (xml:"port").
  - `nmapPort` struct with Protocol `string` (xml attr "protocol"), PortID `int` (xml attr "portid"), State `nmapState` (xml:"state"), Service `nmapService` (xml:"service").
  - `nmapState` struct with State `string` (xml attr "state").
  - `nmapService` struct with Name `string` (xml attr "name"), Product `string` (xml attr "product"), Version `string` (xml attr "version").
- These XML structs should be unexported (lowercase names) since they're internal parsing details.
- Define exported `NmapResult` struct: `IP string`, `Port int`, `Protocol string`, `State string`, `Service string`, `Version string` (JSON tags for each).
- Create `RunNmap(ctx context.Context, ip string, ports []int, binaryPath string) ([]NmapResult, error)`.
  - Takes a SINGLE IP and list of ports to scan on that IP.
  - Use `binary := "nmap"` with binaryPath override.
  - Build port string: join ports with commas (e.g., "80,443,8080").
  - Write XML output to temp file: `-oX tempfile`.
  - Build args: `-sV` (version detection), `-Pn` (skip ping), `-p portString`, `-oX tempfile`, ip.
  - Execute via RunTool.
  - After execution, read XML temp file, unmarshal with `encoding/xml` into `nmapRun`.
  - Convert parsed XML hosts/ports into flat `[]NmapResult` slice. For service version, combine Product and Version (e.g., "Apache httpd 2.4.41") trimming whitespace. If product is empty, use service name.
  - Defer removal of temp file.
  - Return results. If no ports provided, return empty slice immediately.
  </action>
  <verify>
Run `cd C:/Users/Hakim/Desktop/recon-pipeline && go build ./internal/tools/` — should compile with no errors. Also run `go vet ./internal/tools/` for correctness.
  </verify>
  <done>NmapResult type defined. RunNmap executes nmap with -sV -Pn on specific ports, parses XML output via encoding/xml into structured results. XML parsing structs are unexported. Follows existing tool wrapper conventions.</done>
</task>

</tasks>

<verification>
- `go build ./internal/tools/` compiles without errors
- `go vet ./internal/tools/` reports no issues
- All three files exist: cdncheck.go, masscan.go, nmap.go
- Each file exports its Run function and Result type
- All three use RunTool or equivalent exec pattern from runner.go
</verification>

<success_criteria>
Three tool wrappers compile and follow the established pattern. CdncheckResult, MasscanResult, and NmapResult types are defined with proper JSON tags. Each Run function handles edge cases (empty input, parsing errors) gracefully.
</success_criteria>

<output>
After completion, create `.planning/phases/03-cdn-detection-port-scanning/03-01-SUMMARY.md`
</output>
