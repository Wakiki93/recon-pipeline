---
phase: 02-subdomain-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/tools/subfinder.go
  - internal/tools/tlsx.go
  - internal/tools/dig.go
  - internal/tools/runner.go
  - internal/discovery/pipeline.go
  - internal/discovery/dns.go
autonomous: true

must_haves:
  truths:
    - "subfinder wrapper executes with JSON output and returns parsed subdomain results"
    - "tlsx wrapper executes with JSON output and extracts SAN/CN entries"
    - "dig wrapper resolves subdomains to IPs and detects NXDOMAIN vs SERVFAIL"
    - "Subdomains from subfinder and tlsx are deduplicated (case-insensitive, trailing dot stripped, wildcards filtered)"
    - "Unresolved subdomains with CNAME records are flagged as HIGH priority dangling DNS candidates"
    - "Unresolved subdomains without CNAME are flagged as LOW priority stale DNS"
  artifacts:
    - path: "internal/tools/runner.go"
      provides: "Shared subprocess execution with concurrent pipe reading and context timeout"
      exports: ["RunTool", "ToolResult"]
    - path: "internal/tools/subfinder.go"
      provides: "Subfinder wrapper returning parsed subdomains"
      exports: ["RunSubfinder"]
    - path: "internal/tools/tlsx.go"
      provides: "tlsx wrapper returning parsed subdomains from certificate SAN/CN"
      exports: ["RunTlsx"]
    - path: "internal/tools/dig.go"
      provides: "dig wrapper for A/AAAA resolution and CNAME lookup"
      exports: ["ResolveSubdomains", "CheckCNAME"]
    - path: "internal/discovery/pipeline.go"
      provides: "Discovery orchestration: run subfinder+tlsx, deduplicate, resolve"
      exports: ["RunDiscovery", "DiscoveryResult"]
    - path: "internal/discovery/dns.go"
      provides: "DNS resolution and dangling DNS classification"
      exports: ["ResolveBatch", "ClassifyDangling"]
  key_links:
    - from: "internal/tools/subfinder.go"
      to: "internal/tools/runner.go"
      via: "RunTool for subprocess execution"
      pattern: "RunTool"
    - from: "internal/tools/tlsx.go"
      to: "internal/tools/runner.go"
      via: "RunTool for subprocess execution"
      pattern: "RunTool"
    - from: "internal/discovery/pipeline.go"
      to: "internal/tools/subfinder.go"
      via: "RunSubfinder call"
      pattern: "tools\\.RunSubfinder"
    - from: "internal/discovery/pipeline.go"
      to: "internal/tools/tlsx.go"
      via: "RunTlsx call"
      pattern: "tools\\.RunTlsx"
    - from: "internal/discovery/pipeline.go"
      to: "internal/discovery/dns.go"
      via: "ResolveBatch for DNS resolution"
      pattern: "ResolveBatch"
    - from: "internal/discovery/dns.go"
      to: "internal/tools/dig.go"
      via: "dig wrapper for resolution and CNAME checks"
      pattern: "tools\\.(ResolveSubdomains|CheckCNAME)"
---

<objective>
Build the subdomain discovery engine: tool wrappers for subfinder/tlsx/dig, deduplication logic, DNS resolution, and dangling DNS classification.

Purpose: This is the core computation layer that Phase 2 depends on. Without it, the CLI command and report have nothing to produce.
Output: Working discovery pipeline that takes a domain string and returns deduplicated, DNS-resolved subdomains with dangling DNS classification.
</objective>

<execution_context>
@C:/Users/Hakim/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Hakim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:/Users/Hakim/Desktop/recon-pipeline/.planning/PROJECT.md
@C:/Users/Hakim/Desktop/recon-pipeline/.planning/ROADMAP.md
@C:/Users/Hakim/Desktop/recon-pipeline/.planning/STATE.md
@C:/Users/Hakim/Desktop/recon-pipeline/.planning/phases/02-subdomain-discovery/02-RESEARCH.md
@C:/Users/Hakim/Desktop/recon-pipeline/.planning/phases/01-foundation-configuration/01-01-SUMMARY.md
@C:/Users/Hakim/Desktop/recon-pipeline/.planning/phases/01-foundation-configuration/01-02-SUMMARY.md
@C:/Users/Hakim/Desktop/recon-pipeline/internal/models/host.go
@C:/Users/Hakim/Desktop/recon-pipeline/internal/models/types.go
@C:/Users/Hakim/Desktop/recon-pipeline/internal/models/scan.go
@C:/Users/Hakim/Desktop/recon-pipeline/internal/tools/checker.go
@C:/Users/Hakim/Desktop/recon-pipeline/internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Tool wrappers — subfinder, tlsx, dig, and shared runner</name>
  <files>
    internal/tools/runner.go
    internal/tools/subfinder.go
    internal/tools/tlsx.go
    internal/tools/dig.go
  </files>
  <action>
Create a shared subprocess runner and three tool-specific wrappers in `internal/tools/`.

**runner.go** — Shared subprocess execution helper:
- `ToolResult` struct: `Stdout []byte`, `Stderr string`, `ExitCode int`
- `RunTool(ctx context.Context, binary string, args ...string) (*ToolResult, error)` function
- Uses `exec.CommandContext` for timeout enforcement
- Reads stdout and stderr concurrently via goroutines with `bufio.Scanner` (stdout) and `io.Copy` (stderr) to prevent buffer deadlocks (see RESEARCH.md Pattern 1)
- Sets `cmd.WaitDelay = 5 * time.Second` for subprocess cleanup after context cancellation
- Starts readers BEFORE `cmd.Start()`, calls `cmd.Wait()` AFTER readers finish
- Returns wrapped errors with `fmt.Errorf` preserving original error via `%w`

**subfinder.go** — Subfinder wrapper:
- `SubfinderResult` struct: `Host string json:"host"`, `Source string json:"source"`
- `RunSubfinder(ctx context.Context, domain string, threads int) ([]SubfinderResult, error)` function
- Builds args: `-d`, domain, `-silent`, `-oJ`, `-cs` (JSON output with source attribution)
- If threads > 0, adds `-t`, strconv.Itoa(threads)
- Executes via `RunTool`, parses stdout as JSONL (one JSON object per line via `bufio.Scanner` + `json.Unmarshal`)
- Skips lines that fail JSON parse (log warning, continue)
- Returns slice of SubfinderResult

**tlsx.go** — tlsx wrapper:
- `TlsxResult` struct: `SubjectCN string json:"subject_cn"`, `SubjectAN []string json:"subject_an"`, `Host string json:"host"`, `Port string json:"port"`
- `RunTlsx(ctx context.Context, domain string) ([]string, error)` function returning discovered subdomains
- Builds args: `-san`, `-cn`, `-silent`, `-json`
- Pipes domain to stdin (set `cmd.Stdin` to `strings.NewReader(domain)`)
- Parses JSONL output, extracts SubjectCN and all SubjectAN entries
- Filters: skip entries starting with `*` (wildcards), skip entries that don't end with the target domain (out-of-scope)
- Returns deduplicated slice of subdomain strings

**dig.go** — DNS resolution wrapper:
- `DNSResult` struct: `Subdomain string`, `Resolved bool`, `IPs []string`, `CNAME string`, `Error string`
- `ResolveSubdomains(ctx context.Context, subdomains []string) ([]DNSResult, error)` function
- For each subdomain: runs `dig +short <subdomain>` via RunTool
- Parses output: non-empty lines that look like IPs (contains `.` or `:`) = resolved IPs, other non-empty lines may be CNAME chains
- If no IPs found (empty output or only non-IP lines), mark as unresolved
- `CheckCNAME(ctx context.Context, subdomain string) (string, error)` function
- Runs `dig +short CNAME <subdomain>`, returns CNAME target or empty string
- Use individual dig calls (not batch -f mode) for simpler parsing and error handling per subdomain. Batch optimization can come later if needed.

All wrappers use the existing `internal/config.ToolConfig` struct for path overrides (accept binary path as parameter, fall back to tool name if empty).
  </action>
  <verify>
`cd "C:/Users/Hakim/Desktop/recon-pipeline" && go build ./...` compiles without errors. `go vet ./...` reports no issues. Verify all exported functions exist: `grep -n "^func Run\|^func Resolve\|^func Check" internal/tools/*.go`
  </verify>
  <done>
Four files created in internal/tools/. RunTool provides deadlock-safe subprocess execution. RunSubfinder parses JSONL with source attribution. RunTlsx extracts SAN/CN filtering wildcards. ResolveSubdomains + CheckCNAME handle DNS resolution. All compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Discovery pipeline — orchestration, deduplication, and dangling DNS classification</name>
  <files>
    internal/discovery/pipeline.go
    internal/discovery/dns.go
  </files>
  <action>
Create `internal/discovery/` package with pipeline orchestration and DNS classification.

**pipeline.go** — Discovery orchestration:
- `DiscoveryResult` struct:
  - `Target string`
  - `Subdomains []models.Subdomain` (uses existing model from host.go)
  - `TotalFound int` (before dedup)
  - `UniqueCount int` (after dedup)
  - `ResolvedCount int`
  - `DanglingCount int`
  - `Sources map[string]int` (count per source: "subfinder", "tlsx")
- `DiscoveryConfig` struct:
  - `SubfinderThreads int`
  - `SkipTlsx bool` (if tlsx not installed, gracefully skip)
- `RunDiscovery(ctx context.Context, domain string, cfg DiscoveryConfig) (*DiscoveryResult, error)` function:
  1. Run `tools.RunSubfinder(ctx, domain, cfg.SubfinderThreads)` — collect results
  2. If !cfg.SkipTlsx: Run `tools.RunTlsx(ctx, domain)` — collect results
  3. Normalize all subdomains: `strings.ToLower()`, `strings.TrimSuffix(s, ".")`, `strings.TrimSpace()`
  4. Deduplicate using `map[string]string` where key=normalized subdomain, value=source (first source wins). Track TotalFound before dedup.
  5. Build `[]models.Subdomain` from deduped map, setting Name, Domain, Source fields
  6. Call `ResolveBatch(ctx, subdomains)` to resolve DNS and classify dangling
  7. Populate counts (ResolvedCount, DanglingCount) and return DiscoveryResult

Use `map[string]string` for dedup instead of `unique` package — simpler, proven pattern, and we need source tracking anyway. The unique package optimization is unnecessary for typical subdomain counts (hundreds to low thousands).

**dns.go** — DNS resolution and dangling classification:
- `ResolveBatch(ctx context.Context, subdomains []models.Subdomain) ([]models.Subdomain, error)` function:
  - Iterates over subdomains slice (passed by value, returns modified copy)
  - For each: calls `tools.ResolveSubdomains(ctx, []string{sub.Name})` to get DNS result
  - If resolved: set `sub.Resolved = true`, `sub.IPs = result.IPs`
  - If not resolved: call `tools.CheckCNAME(ctx, sub.Name)`
    - If CNAME found: set `sub.IsDangling = true`, add CNAME to `sub.DNSRecords` as `models.DNSRecord{Type: models.DNSRecordCNAME, Value: cname}`
    - If no CNAME: set `sub.IsDangling = true` (stale DNS, lower priority — no CNAME means not a takeover candidate, but still flagged for tracking)
  - Returns updated subdomains slice
- `ClassifyDangling(subdomains []models.Subdomain) (highPriority, lowPriority []models.Subdomain)` function:
  - High priority: IsDangling=true AND has CNAME record (subdomain takeover candidate)
  - Low priority: IsDangling=true AND no CNAME record (stale DNS cleanup)
  - Returns two slices for report generation

Note: ResolveBatch processes sequentially for now. Concurrent resolution can be added later when performance matters (Phase 6+ with large scan history). Keep it simple.
  </action>
  <verify>
`cd "C:/Users/Hakim/Desktop/recon-pipeline" && go build ./...` compiles without errors. `go vet ./...` reports no issues. Verify discovery package exists: `grep -n "^func Run\|^func Resolve\|^func Classify" internal/discovery/*.go`. Verify models.Subdomain is used (not a custom type): `grep "models.Subdomain" internal/discovery/*.go`
  </verify>
  <done>
Two files created in internal/discovery/. RunDiscovery orchestrates subfinder+tlsx, normalizes and deduplicates subdomains, resolves DNS, and classifies dangling entries. ResolveBatch handles per-subdomain resolution with CNAME fallback. ClassifyDangling separates high-priority (CNAME takeover) from low-priority (stale DNS). All types use existing models.Subdomain. Compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` — all packages compile
2. `go vet ./...` — no static analysis issues
3. Verify tool wrappers exist with correct signatures
4. Verify discovery pipeline imports and uses models.Subdomain (not custom types)
5. Verify deduplication normalizes case and trailing dots
6. Verify dangling DNS two-stage detection (A/AAAA then CNAME)
</verification>

<success_criteria>
- internal/tools/ has runner.go, subfinder.go, tlsx.go, dig.go with exported functions
- internal/discovery/ has pipeline.go, dns.go with RunDiscovery, ResolveBatch, ClassifyDangling
- All code compiles and passes go vet
- Discovery pipeline uses existing models.Subdomain struct
- Deduplication handles case normalization, trailing dots, wildcard filtering
- Dangling DNS detection distinguishes CNAME-based (high priority) from no-record (low priority)
</success_criteria>

<output>
After completion, create `.planning/phases/02-subdomain-discovery/02-01-SUMMARY.md`
</output>
