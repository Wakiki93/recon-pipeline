---
phase: 02-subdomain-discovery
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - internal/report/markdown.go
  - cmd/reconpipe/discover.go
autonomous: true

must_haves:
  truths:
    - "User can run 'reconpipe discover -d example.com' to discover subdomains"
    - "Command creates scan directory, saves scan metadata to bbolt, runs discovery pipeline"
    - "Pipeline produces subdomains.md report in the scan's reports/ directory"
    - "Report shows resolved subdomains with IPs, dangling DNS candidates with CNAME targets, and summary statistics"
    - "Command outputs progress to terminal (starting, tool running, complete) and final summary"
  artifacts:
    - path: "internal/report/markdown.go"
      provides: "Markdown report generation for subdomain discovery results"
      exports: ["WriteSubdomainReport"]
    - path: "cmd/reconpipe/discover.go"
      provides: "Cobra discover command wiring pipeline + storage + report"
      exports: ["discoverCmd"]
  key_links:
    - from: "cmd/reconpipe/discover.go"
      to: "internal/discovery/pipeline.go"
      via: "RunDiscovery call"
      pattern: "discovery\\.RunDiscovery"
    - from: "cmd/reconpipe/discover.go"
      to: "internal/storage"
      via: "SaveScan and UpdateScanStatus for metadata persistence"
      pattern: "store\\.(SaveScan|UpdateScanStatus)"
    - from: "cmd/reconpipe/discover.go"
      to: "internal/report/markdown.go"
      via: "WriteSubdomainReport to generate report file"
      pattern: "report\\.WriteSubdomainReport"
    - from: "cmd/reconpipe/discover.go"
      to: "internal/tools/checker.go"
      via: "CheckTool to verify subfinder/dig available before running"
      pattern: "tools\\.CheckTool"
---

<objective>
Build the user-facing layer: markdown report generator and `reconpipe discover` CLI command that wires everything together.

Purpose: This makes Phase 2 usable. Plan 01 built the engine; this plan connects it to the CLI and produces the deliverable (subdomains.md report).
Output: Working `reconpipe discover -d <domain>` command that runs the full subdomain discovery pipeline and produces a markdown report.
</objective>

<execution_context>
@C:/Users/Hakim/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Hakim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:/Users/Hakim/Desktop/recon-pipeline/.planning/PROJECT.md
@C:/Users/Hakim/Desktop/recon-pipeline/.planning/ROADMAP.md
@C:/Users/Hakim/Desktop/recon-pipeline/.planning/STATE.md
@C:/Users/Hakim/Desktop/recon-pipeline/.planning/phases/02-subdomain-discovery/02-RESEARCH.md
@C:/Users/Hakim/Desktop/recon-pipeline/.planning/phases/02-subdomain-discovery/02-01-SUMMARY.md
@C:/Users/Hakim/Desktop/recon-pipeline/internal/models/host.go
@C:/Users/Hakim/Desktop/recon-pipeline/internal/models/scan.go
@C:/Users/Hakim/Desktop/recon-pipeline/internal/config/config.go
@C:/Users/Hakim/Desktop/recon-pipeline/internal/storage/filesystem.go
@C:/Users/Hakim/Desktop/recon-pipeline/internal/storage/scans.go
@C:/Users/Hakim/Desktop/recon-pipeline/cmd/reconpipe/root.go
@C:/Users/Hakim/Desktop/recon-pipeline/cmd/reconpipe/check.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Markdown report generator for subdomain discovery</name>
  <files>
    internal/report/markdown.go
  </files>
  <action>
Create `internal/report/` package with markdown report generation.

**markdown.go** — Subdomain report generator:
- `WriteSubdomainReport(result *discovery.DiscoveryResult, outputPath string) error` function
- Uses `strings.Builder` for efficient string concatenation (see RESEARCH.md Pattern 5)
- Report structure (written to outputPath as subdomains.md):

```
# Subdomain Discovery Report

**Target:** {target}
**Date:** {time.Now().Format("2006-01-02 15:04:05")}
**Total discovered:** {TotalFound} | **Unique:** {UniqueCount} | **Resolved:** {ResolvedCount} | **Dangling:** {DanglingCount}

## Sources

| Source | Count |
|--------|-------|
| subfinder | {n} |
| tlsx | {n} |

## Resolved Subdomains

| Subdomain | IPs | Source |
|-----------|-----|--------|
| sub.example.com | 1.2.3.4, 5.6.7.8 | subfinder |

## Dangling DNS - High Priority (Takeover Candidates)

| Subdomain | CNAME Target | Source |
|-----------|-------------|--------|
| old.example.com | old.example.com.s3.amazonaws.com | subfinder |

## Dangling DNS - Low Priority (Stale DNS)

| Subdomain | Source |
|-----------|--------|
| stale.example.com | tlsx |

## Unresolved (No DNS Records)

| Subdomain | Source |
|-----------|--------|
```

- If a section has no entries, write "None found." instead of empty table
- Use `discovery.ClassifyDangling()` to split dangling into high/low priority
- Write file with `os.WriteFile(outputPath, []byte(report.String()), 0644)`
- Return error if write fails
  </action>
  <verify>
`cd "C:/Users/Hakim/Desktop/recon-pipeline" && go build ./...` compiles without errors. `go vet ./...` reports no issues. Verify export: `grep -n "^func Write" internal/report/markdown.go`
  </verify>
  <done>
internal/report/markdown.go created with WriteSubdomainReport. Report includes summary stats, source breakdown, resolved subdomains table, high-priority dangling DNS (CNAME takeover candidates), low-priority stale DNS, and handles empty sections gracefully. Uses strings.Builder for performance.
  </done>
</task>

<task type="auto">
  <name>Task 2: Cobra discover command — wire pipeline + storage + report</name>
  <files>
    cmd/reconpipe/discover.go
  </files>
  <action>
Create `cmd/reconpipe/discover.go` — the user-facing discover command.

**discover.go** — Cobra command implementation:
- `discoverCmd` variable of type `*cobra.Command`
- Command: `discover`, Short: "Discover subdomains for a target domain"
- Flags:
  - `-d, --domain` (string, required) — target domain
  - `--skip-tlsx` (bool, default false) — skip tlsx if not installed or not wanted
  - `--timeout` (duration, default 10m) — overall discovery timeout
- In `init()`: add discoverCmd to rootCmd via `rootCmd.AddCommand(discoverCmd)`
- Mark domain flag as required: `discoverCmd.MarkFlagRequired("domain")`

**RunE function flow:**
1. **Pre-flight check:** Use `tools.CheckTool()` to verify subfinder and dig are available. If either missing, return error with install instructions. Check tlsx — if missing and --skip-tlsx not set, print warning and auto-skip (don't fail).
2. **Config loading:** Config is loaded by root PersistentPreRunE. Access via package-level `cfg` variable. If cfg is nil (config not loaded), return helpful error: "Run 'reconpipe init' first to create config"
3. **Create scan:** Call `models.NewScan(domain)` to create scan with UUID and timestamp
4. **Create scan directory:** Call `storage.CreateScanDir(cfg.ScanDir, domain, scan.StartedAt)` — sets `scan.ScanDir` to returned path
5. **Open database:** Call `storage.NewStore(cfg.DBPath)` — defer `store.Close()`
6. **Save scan metadata:** Call `store.SaveScan(&scan.ScanMeta)` with StatusRunning
7. **Print progress:** `fmt.Printf("[*] Starting subdomain discovery for %s\n", domain)`
8. **Create context with timeout:** `ctx, cancel := context.WithTimeout(context.Background(), timeout)` — defer cancel
9. **Build DiscoveryConfig:** Set SubfinderThreads from `cfg.RateLimits.SubfinderThreads`, set SkipTlsx based on flag + tool availability
10. **Run discovery:** `result, err := discovery.RunDiscovery(ctx, domain, discoveryCfg)`
11. **Handle error:** If error, call `store.UpdateScanStatus(scan.ID, models.StatusFailed)`, print error, return
12. **Print progress:** `fmt.Printf("[+] Found %d unique subdomains (%d resolved, %d dangling)\n", result.UniqueCount, result.ResolvedCount, result.DanglingCount)`
13. **Write report:** Call `report.WriteSubdomainReport(result, filepath.Join(scan.ScanDir, "reports", "subdomains.md"))`
14. **Save raw output:** Write `result.Subdomains` as JSON to `filepath.Join(scan.ScanDir, "raw", "subdomains.json")` using `json.MarshalIndent`
15. **Update scan metadata:** Set `scan.Subdomains = result.Subdomains`, `scan.StagesRun = append(scan.StagesRun, "discover")`, call `store.UpdateScanStatus(scan.ID, models.StatusComplete)`
16. **Print summary:** Final message with report path: `fmt.Printf("[+] Report written to %s\n", reportPath)`

**Error handling pattern:**
- Wrap all errors with context: `fmt.Errorf("creating scan directory: %w", err)`
- On pipeline failure: still update scan status to Failed before returning error
- On report write failure: warn but don't fail the whole command (discovery data is still in raw/)

**Important:** The discover command needs config, so do NOT add "discover" to the skipConfig map in root.go. Config loading in PersistentPreRunE will handle it. However, check that cfg loaded properly at start of RunE (cfgFile might not exist).
  </action>
  <verify>
`cd "C:/Users/Hakim/Desktop/recon-pipeline" && go build -o reconpipe.exe ./cmd/reconpipe/` builds successfully. `./reconpipe.exe discover --help` shows domain flag and usage. `./reconpipe.exe discover` without -d flag shows required flag error. `go vet ./...` reports no issues.
  </verify>
  <done>
cmd/reconpipe/discover.go created and wired to rootCmd. User can run `reconpipe discover -d example.com` to: verify tools are available, create scan directory and metadata, run subfinder+tlsx discovery with deduplication, resolve DNS and classify dangling, write subdomains.md report and raw JSON, and update scan status. Command shows progress output and handles errors gracefully.
  </done>
</task>

</tasks>

<verification>
1. `go build -o reconpipe.exe ./cmd/reconpipe/` — binary builds
2. `./reconpipe.exe discover --help` — shows usage with -d flag
3. `./reconpipe.exe discover` — errors about required -d flag
4. `go vet ./...` — no issues
5. Report generation uses discovery.ClassifyDangling for high/low priority split
6. Discover command creates scan dir, saves metadata, runs pipeline, writes report
7. All Phase 2 success criteria addressable via single `reconpipe discover -d <domain>` command
</verification>

<success_criteria>
- `reconpipe discover -d example.com` runs the full subdomain discovery pipeline
- Pipeline creates scan directory under configured scan_dir
- Pipeline saves scan metadata to bbolt database
- Pipeline produces subdomains.md in {scanDir}/reports/ with resolved, dangling (high+low), and summary sections
- Pipeline produces subdomains.json in {scanDir}/raw/ with structured data
- Pre-flight tool check prevents running without required tools
- Progress output shown to terminal during execution
- Scan status updated to complete or failed in database
</success_criteria>

<output>
After completion, create `.planning/phases/02-subdomain-discovery/02-02-SUMMARY.md`
</output>
